<?php
/**
 * @file
 * Code for the OpenAtrium2 Groups feature.
 */

include_once 'oa_groups.features.inc';

/**
 * Name of default OpenAtrium Group type.
 */
define('OA_GROUP_TYPE', 'oa_group');
/**
 * Name of OpenAtrium Section content type.
 */
define('OA_SECTION_TYPE', 'oa_section');
/**
 * Name of OpenAtrium Organization content type.
 */
define('OA_ORG_TYPE', 'oa_organization');
/**
 * Name of OpenAtrium Team content type.
 */
define('OA_TEAM_TYPE', 'oa_team');
/**
 * Name of default OpenAtrium Section field (for Organic Groups Fields UI).
 */
define('OA_SECTION_FIELD', 'oa_section_ref');
/**
 * Name of default OpenAtrium Group field (for Organic Groups Fields UI).
 */
define('OA_GROUP_FIELD', 'og_group_ref');
/**
 * Name of default OpenAtrium Organization field (for Organic Groups Fields UI).
 */
define('OA_ORG_FIELD', 'field_oa_organization_ref');
/**
 * Name of default OpenAtrium Team field (for Organic Groups Fields UI).
 */
define('OA_TEAM_FIELD', 'field_oa_team_ref');

/**
 * Determine if a user is a member of a team
 * @param  int $team_id
 * @param  int $user_id
 * @return boolean TRUE if user is in team
 */
function oa_groups_member_of_team($team_id, $user_id) {
  static $cache = array();

  if (!isset($cache[$team_id][$user_id])) {
    $query = new EntityFieldQuery();
    $query
      ->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', OA_TEAM_TYPE)
      ->entityCondition('entity_id', $team_id)
      ->propertyCondition('status', 1)
      ->fieldCondition('field_oa_team_users', 'target_id', $user_id, '=');
    $result = $query->execute();
    $cache[$team_id][$user_id] = (!empty($result['node'])) ? TRUE : FALSE;
    if (empty($result['node'])) {
      // not explicitly in team, but check ownership of team node
      $node = node_load($team_id);
      $cache[$team_id][$user_id] = ($node->uid == $user_id) ? TRUE : FALSE;
    }
  }
  return $cache[$team_id][$user_id];
}

/**
 * Determine access to a Open Atrium Section
 * Same arguments as hook_node_access
 */
function oa_groups_section_access($node, $op, $account) {
  // Handle access to a section
  if (empty($node->field_oa_organization_ref[LANGUAGE_NONE]) &&
      empty($node->field_oa_team_ref[LANGUAGE_NONE]) &&
      empty($node->field_oa_user_ref[LANGUAGE_NONE])) {
    // No access fields are set, so it's a public section
    return NODE_ACCESS_IGNORE;
  }

  if ($account->uid == 0) {
    // anonymous users not allowed to see sections with any access fields
    return NODE_ACCESS_DENY;
  }

  // Test Organization membership
  if (!empty($node->field_oa_organization_ref[LANGUAGE_NONE])) {
    $org_ids = array();
    foreach ($node->field_oa_organization_ref[LANGUAGE_NONE] as $org_ref) {
      $org_ids[] = $org_ref['target_id'];
    }
    $groups = og_get_entity_groups('user', $account);
    foreach ($groups as $group_type => $gids) {
      foreach ($gids as $gid) {
        if (in_array($gid, $org_ids)) {
          return NODE_ACCESS_ALLOW;
        }
      }
    }
  }

  // Test Team membership
  if (!empty($node->field_oa_team_ref[LANGUAGE_NONE])) {
    foreach ($node->field_oa_team_ref[LANGUAGE_NONE] as $team_ref) {
      if (oa_groups_member_of_team($team_ref['target_id'], $account->uid)) {
        return NODE_ACCESS_ALLOW;
      }
    }
  }

  // Test User membership
  if (!empty($node->field_oa_user_ref[LANGUAGE_NONE])) {
    foreach ($node->field_oa_user_ref[LANGUAGE_NONE] as $team_ref) {
      if ($team_ref['target_id'] == $account->uid) {
        return NODE_ACCESS_ALLOW;
      }
    }
  }

  // none of the organizations, teams, or users allowed access, so deny access
  return NODE_ACCESS_DENY;

}

/**
 * Returns TRUE if we are caching section access in db
 */
function oa_groups_cache_enabled() {
  return (module_exists('oa_section_access') &&
    variable_get('oa_access_cache', TRUE));
}

/**
 * Check for any database cache of section access data
 * @param  int $user_id
 * @return array $section_list array
 *   or NULL if no cache entries exists
 */
function oa_groups_get_section_cache($user_id) {
  $section_list = NULL;
  if (oa_groups_cache_enabled()) {
    $or = db_or();
    $or->condition('uid', $user_id);
    if ($user_id != 0) {
      // also include any public sections
      $or->condition('uid', 0);
    }
    $result = db_select('oa_section_access', 's')
      ->fields('s', array('sid', 'gid'))
      ->condition($or)
      ->execute();
    if ($result->rowCount() > 0) {
      $section_list = array();
      // build section list from table cache
      while ($row = $result->fetchAssoc()) {
        if (!isset($section_list[$row['gid']])) {
          $section_list[$row['gid']] = array();
        }
        $section_list[$row['gid']][] = $row['sid'];
      }
    }
  }
  return $section_list;
}

/**
 * update oa_section_access db cache table
 * if Access is IGNORE then it's a public section, so allow anonymous access
 * @return [type] [description]
 */
/**
 * update oa_section_access db cache table
 * @param  int $sid    section id
 * @param  int $uid    user id
 * @param  int $gid    group id
 * @param  $access NODE_ACCESS_ALLOW or NODE_ACCESS_IGNORE
 */
function oa_groups_update_section_cache($sid, $gid, $uid, $access) {
  // if Access is IGNORE then it's a public section, so allow anonymous access
  if (oa_groups_cache_enabled()) {
    $user_id = ($access == NODE_ACCESS_IGNORE) ? 0 : $uid;
    $record = array(
      'uid' => $user_id,
      'sid' => $sid,
      'gid' => $gid,
    );
    // first remove any existing rows for this access
    db_delete('oa_section_access')
      ->condition('uid', $user_id)
      ->condition('sid', $sid)
      ->execute();
    if ($uid != $user_id) {
      // also remove any old access for this specific user
      db_delete('oa_section_access')
        ->condition('uid', $uid)
        ->condition('sid', $sid)
        ->execute();
    }
    // now write new access records
    drupal_write_record('oa_section_access', $record);
  }
}

/**
 * Return a list of sections and groups a user can access
 * @param  int $user_id
 * @return array keyed by group_id, nested array of section ids
 */
function oa_groups_section_list($user_id) {
  static $cache = array();
  if (isset($cache[$user_id])) {
    return $cache[$user_id];
  }

  // look up section access data for user
  // return list of sections this user has access to
  $section_list = oa_groups_get_section_cache($user_id);
  if (!is_null($section_list)) {
    $cache[$user_id] = $section_list;
    return $section_list;
  }
  // otherwise the oa_section_access cache table was empty
  // so rebuild entries for this user

  $account = user_load($user_id);
  $section_list = array();
  // First, get list of groups user is a member of
  if ($account->uid == 0) {
    // og_get_entity_groups doesn't return anything for anonymous users
    // so return list of all public groups
    $groups = oa_get_public_groups();
  }
  else {
    $groups = og_get_entity_groups('user', $account);
  }
  if (!empty($groups['node'])) {
    foreach ($groups['node'] as $gid) {
      $section_list[$gid] = array();
    }
    // get the list of all section nodes assigned to the list of groups
    $query = db_select('node', 'n');
    $query->rightJoin('og_membership', 'og', 'n.nid = og.etid');
    $query
      ->fields('n', array('nid', 'title'))
      ->fields('og', array('gid'))
      ->condition('n.type', OA_SECTION_TYPE)
      ->condition('og.entity_type', 'node')
      ->condition('og.field_name', OA_GROUP_FIELD)
      ->condition('og.gid', $groups['node'], 'IN');
    $result = $query->execute();
    // loop through each result to determine access to section
    while ($row = $result->fetchAssoc()) {
      // load the section node
      $node = node_load($row['nid']);
      $access = oa_groups_section_access($node, 'view', $account);
      if (($access == NODE_ACCESS_ALLOW) || ($access == NODE_ACCESS_IGNORE)) {
        $section_list[$row['gid']][$row['nid']] = $row['nid'];
        oa_groups_update_section_cache($row['nid'], $row['gid'], $user_id, $access);
      }
    }
  }

  $cache[$user_id] = $section_list;
  return $section_list;
}

/**
 * Takes the nested list of a user's groups/sections and returns a list
 * of just unique section numbers
 * @param  array $section_list
 * @return array
 */
function oa_groups_flatten_section($section_list) {
  $result = array();
  foreach ($section_list as $gid => $list) {
    foreach ($list as $key => $value) {
      $result[$value] = $value;
    }
  }
  return $result;
}

/**
 * Implements hook_node_access.
 */
function oa_groups_node_access($node, $op, $account) {
  if (!is_object($node)) {
    // only interested in actual nodes
    return NODE_ACCESS_IGNORE;
  }
  if ($node->type == OA_SECTION_TYPE) {
    $sections = oa_groups_section_list($account->uid);
    $sections = oa_groups_flatten_section($sections);
    if (isset($sections[$node->nid])) {
      return NODE_ACCESS_ALLOW;
    }
    else {
      return NODE_ACCESS_DENY;
    }
  }
  // Look for the default OA_SECTION_FIELD
  if (!empty($node->{OA_SECTION_FIELD})) {
    $sections = oa_groups_section_list($account->uid);
    $sections = oa_groups_flatten_section($sections);
    // Found a section reference, so defer access to section
    // Loop through referenced sections to test access
    foreach ($node->{OA_SECTION_FIELD}[LANGUAGE_NONE] as $entity_ref) {
      if (isset($sections[$entity_ref['target_id']])) {
        return NODE_ACCESS_ALLOW;
      }
    }
    // none of the sections allowed access, so deny access
    return NODE_ACCESS_DENY;
  }

  return NODE_ACCESS_IGNORE;
}

/**
 * Implements hook_og_fields_info().
 */
function oa_groups_og_fields_info() {
  $items[OA_SECTION_FIELD] = array(
    'no ui' => TRUE,
    'type' => array('group content'),
    'description' => t('Determine to which Open Atrium section this group content is assigned to.'),
    'field' => array(
      'field_name' => OA_SECTION_FIELD,
      'type' => 'entityreference',
      'cardinality' => 1,
      'module' => 'entityreference',
      'settings' => array(
        'handler' => 'base',
        'handler_settings' => array(
          'behaviors' => array(
            'views-select-list' => array(
              'status' => 0,
            ),
          ),
          'sort' => array(
            'type' => 'none',
          ),
          'target_bundles' => array(
            OA_SECTION_TYPE => OA_SECTION_TYPE,
          ),
        ),
        'target_type' => 'node',
      ),
      'translatable' => '0',
      'type' => 'entityreference',
    ),
    'instance' => array(
      'label' => t('Open Atrium Section'),
      'widget' => array(
        'active' => 0,
        'module' => 'options',
        'settings' => array(
          'match_operator' => 'CONTAINS',
          'path' => '',
          'size' => 60,
        ),
        'type' => 'options_select',
        'weight' => '7',
      ),
    ),
  );

  return $items;
}

/**
 * Returns a list of content types throughout the system. List
 *   leaves out content types specified by other modules/apps.
 *
 * @return array of strings denoting content types marked for omission
 */
function oa_groups_list_content_types() {
  $nodes = node_type_get_types();

  // Queries hook_oa_omit_content_types to determine what content types
  //   modules wants to hide.
  $deny = module_invoke_all('oa_omit_content_types');
  if (!empty($deny)) {
    foreach ($deny as $remove) {
      unset($nodes[$remove]);
    }
  }

  return $nodes;
}

/**
 * Helper function to retrieve an array of node titles and links given
 * a list of node ids
 * @param  array  $ids array of node ids to fetch
 * @param  string $type optional node type to filter
 * @return array      associative array:
 *   'titles' is a list of node titles (clean)
 *   'links' is a list of node links
 *   'ids' is a list of the node ids
 */
function oa_groups_get_titles($ids = array(), $type = '') {
  $items = array('titles' => array(), 'links' => array(), 'ids' => array());
  if (!empty($ids)) {
    $query = db_select('node', 'n');
    $query
      ->fields('n', array('nid', 'title'))
      ->condition('n.nid', $ids, 'IN');
    if (!empty($type)) {
      $query->condition('n.type', $type);
    }
    $result = $query->execute();
    while ($row = $result->fetchAssoc()) {
      $items['ids'][]    = $row['nid'];
      $items['titles'][] = check_plain($row['title']);
      $items['links'][]  = l($row['title'], 'node/' . $row['nid']);
    }
  }
  return $items;
}

/**
 * truncate a list to a given number of items with optional More link
 * @param  array $list      array to be truncated
 * @param  int $count     number of items desired
 * @param  string $more_link optional "More" link added to end of array
 * @return array            new list of items
 */
function oa_groups_truncate_list($list, $count, $more_link = '') {
  $new_list = array_slice($list, 0, $count);
  if (!empty($more_link) && (count($list) != count($new_list))) {
    $new_list[] = $more_link;
  }
  return $new_list;
}

/**
 * Return a list of public groups
 * since og_get_entity_groups doesn't return anything for anonymous users
 * @return array array['node'] contains array of public gids
 */
function oa_get_public_groups() {
  $query = db_select('field_data_group_access', 'g')
    ->fields('g', array('entity_id'))
    ->condition('bundle', OA_GROUP_TYPE)
    ->condition('entity_type', 'node')
    ->condition('group_access_value', 0);
  $result['node'] = $query->execute()->fetchCol(0);
  return $result;
}
