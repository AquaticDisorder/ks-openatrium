<?php
/**
 * @file
 * Code for the OpenAtrium Core feature.
 */

include_once 'oa_core.features.inc';
include_once 'oa_core.theme.inc';

/**
 * Name of default OpenAtrium Space type.
 */
define('OA_SPACE_TYPE', 'oa_space');
/**
 * Name of OpenAtrium Section content type.
 */
define('OA_SECTION_TYPE', 'oa_section');
/**
 * Name of OpenAtrium Group content type.
 */
define('OA_GROUP_TYPE', 'oa_group');
/**
 * Name of OpenAtrium Team content type.
 */
define('OA_TEAM_TYPE', 'oa_team');
/**
 * Name of default OpenAtrium Section field (for Organic Groups Fields UI).
 */
define('OA_SECTION_FIELD', 'oa_section_ref');
/**
 * Name of default OpenAtrium Group field (for Organic Groups Fields UI).
 */
define('OA_SPACE_FIELD', 'og_group_ref');
/**
 * The access realm of space member.
 */
define('OA_ACCESS_REALM', 'oa_access');

/**
 * Implements hook_ctools_plugin_directory().
 */
function oa_core_ctools_plugin_directory($owner, $plugin_type) {
  if ($owner == 'ctools' && $plugin_type == 'content_types') {
    return 'plugins/content_types';
  }
}

/**
 * Implementation of hook_menu
 */
function oa_core_menu() {
 // Add an administration section for Open Atrium settings
  $items['admin/openatrium/settings'] = array(
    'title' => 'Open Atrium Settings',
    'description' => 'Configuration related to Open Atrium',
    'weight' => 0,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('oa_core_configure_form'),
    'access arguments' => array('administer site configuration'),
  );
  return $items;
}

/**
 * Configuration Form for Open Atrium
 */
function oa_core_configure_form($form, &$form_state) {
  // blank for for now.  Other modules can alter this to add stuff
  $form = array();
  return system_settings_form($form);
}

/**
 * Determine if a user is a member of a team
 * @param  int $team_id
 * @param  int $user_id
 * @return boolean TRUE if user is in team
 */
function oa_core_member_of_team($team_id, $user_id) {
  $cache = &drupal_static(__FUNCTION__);

  if (!isset($cache[$team_id][$user_id])) {
    $result = db_select('field_data_field_oa_team_users', 'f')
      ->fields('f', array('field_oa_team_users_target_id'))
      ->condition('field_oa_team_users_target_id', $user_id)
      ->condition('entity_type', 'node')
      ->condition('entity_id', $team_id)
      ->condition('deleted', 0)
      ->execute();
    if ($result->rowCount() > 0) {
      $access = TRUE;
    }
    else {
      // not explicitly in team, but check ownership of team node
      // do NOT use node_load as this is called from hook_node_grants()
      $result = db_select('node', 'n')
        ->fields('n', array('uid'))
        ->condition('nid', $team_id)
        ->execute()
        ->fetchAssoc();
      $access = ($result['uid'] == $user_id) ? TRUE : FALSE;
    }
    $cache[$team_id][$user_id] = $access;
  }

  return $cache[$team_id][$user_id];
}

/**
 * Returns TRUE if the section $node has open access to public
 */
function oa_core_section_is_public($node) {
  return (
       empty($node->field_oa_group_ref[LANGUAGE_NONE])
    && empty($node->field_oa_team_ref[LANGUAGE_NONE])
    && empty($node->field_oa_user_ref[LANGUAGE_NONE])
    );
}

/**
 * Determine access to a Open Atrium Section
 * do NOT use node_load here as it gets called from hook_node_grants()
 */
function oa_core_section_access($row, $spaces, $account) {

  $gid = $row['field_oa_group_ref_target_id'];
  $team_id = $row['field_oa_team_ref_target_id'];
  $user_id = $row['field_oa_user_ref_target_id'];

  // check if no access fields are set
  if (is_null($gid) && is_null($team_id) && is_null($user_id)) {
    return NODE_ACCESS_ALLOW;
  }

  // Test Group membership
  if (!is_null($gid) && !empty($spaces['node'])) {
    if (in_array($gid, $spaces['node'])) {
      return NODE_ACCESS_ALLOW;
    }
  }

  // Test Team membership
  if (!is_null($team_id)) {
    if (oa_core_member_of_team($team_id, $account->uid)) {
      return NODE_ACCESS_ALLOW;
    }
  }

  // Test User membership
  if (!is_null($user_id)) {
    if ($user_id == $account->uid) {
      return NODE_ACCESS_ALLOW;
    }
  }

  // none of the groups, teams, or users allowed access, so deny access
  return NODE_ACCESS_DENY;
}

/**
 * Implements hook_node_grants().
 * Define node access grant realm for Open Atrium sections
 */
function oa_core_node_grants($account, $op) {
  static $cache = array();

  if ($op != 'view') {
    return;
  }

  if (isset($cache[$account->uid])) {
    return $cache[$account->uid];
  }
  $member_spaces = og_get_entity_groups('user', $account);
  // add the list of public spaces that user might not be explicitly
  // a member of, but can access content within
  $spaces = array_merge($member_spaces, oa_core_get_public_spaces());
  if (!empty($spaces['node'])) {
    // get the list of all section nodes assigned to the list of spaces
    $query = db_select('node', 'n');
    $query->join('og_membership', 'og', 'n.nid = og.etid');
    $query
      ->fields('n', array('nid'))
      ->condition('n.type', OA_SECTION_TYPE)
      ->condition('og.entity_type', 'node')
      ->condition('og.field_name', OA_SPACE_FIELD)
      ->condition('og.gid', $spaces['node'], 'IN');
    $result = $query->execute();
    // get a list of sections that don't have any access fields
    // loop through each result to determine access to section
    $sections = $result->fetchCol(0);

    // do a big complex query to grab all section access fields
    // might be a way to merge this with the previous query
    // but it makes my brain hurt
    $query = db_select('node', 'n');
    // we join with the Groups, Teams, Users fields
    $query->leftJoin('field_data_field_oa_group_ref', 'o', "n.nid = o.entity_id AND o.entity_type = 'node'");
    $query->leftJoin('field_data_field_oa_team_ref', 't', "n.nid = t.entity_id AND t.entity_type = 'node'");
    $query->leftJoin('field_data_field_oa_user_ref', 'u', "n.nid = u.entity_id AND u.entity_type = 'node'");
    $query
      ->fields('n', array('nid'))
      ->fields('o', array('field_oa_group_ref_target_id'))
      ->fields('t', array('field_oa_team_ref_target_id'))
      ->fields('u', array('field_oa_user_ref_target_id'))
      ->condition('n.type', OA_SECTION_TYPE)
      ->condition('n.nid', $sections, 'IN');
    $result = $query->execute();

    while ($row = $result->fetchAssoc()) {
      $sid = $row['nid'];
      // only check detailed access for non-public sections
      $access = oa_core_section_access($row, $member_spaces, $account);
      if (($access == NODE_ACCESS_ALLOW) || ($access == NODE_ACCESS_IGNORE)) {
        $grants[OA_ACCESS_REALM][] = $sid;
      }
    }
  }

  $cache[$account->uid] = !empty($grants) ? $grants : array();
  return $cache[$account->uid];
}

/**
 * Implements hook_node_access_records().
 */
function oa_core_node_access_records($node) {
  $sids = array();
  if ($node->status == 0) {
    // don't change access for unpublished nodes
    // keep normal Drupal access (should be set for only Own access)
  }
  else if ($node->type == OA_SECTION_TYPE) {
    if (!oa_core_section_is_public($node)) {
      $sids[] = $node->nid;
    }
  }
  // Look for the default section reference
  else if (!empty($node->{OA_SECTION_FIELD})) {
    foreach ($node->{OA_SECTION_FIELD}[LANGUAGE_NONE] as $entity_ref) {
      $section = node_load($entity_ref['target_id']);
      if (!oa_core_section_is_public($section)) {
        $sids[] = $entity_ref['target_id'];
      }
    }
  }
  if (empty($sids)) {
    return array();
  }

  foreach ($sids as $sid) {
    $grants[] = array (
      'realm' => OA_ACCESS_REALM,
      'gid' => $sid,
      'grant_view' => 1,
      'grant_update' => 0,
      'grant_delete' => 0,
      'priority' => 0,
    );
  }

  return !empty($grants) ? $grants : array();
}

/**
 * Update the node_access_records of the given nodes
 * @param  array $nodes array of nids
 */
function oa_core_update_access_records($nodes) {
  foreach ($nodes as $nid) {
    $node = node_load($nid);
    node_access_acquire_grants($node);
  }
}

/**
 * Implements hook_node_update
 * if saving a section or space node, update access locks on related content
 */
function oa_core_node_update($node) {
  if ($node->type == OA_SPACE_TYPE) {
    // check if group access changed and update space content grants
    if (isset($node->group_access[LANGUAGE_NONE][0]['value']) &&
      isset($node->original->group_access[LANGUAGE_NONE][0]['value']) &&
      ($node->group_access[LANGUAGE_NONE][0]['value'] !=
       $node->original->group_access[LANGUAGE_NONE][0]['value'])) {
      // rebuild space content nodes
      $nodes = db_select('og_membership', 'og')
        ->fields('og', array('etid'))
        ->condition('og.entity_type', 'node')
        ->condition('og.gid', $node->nid)  // all content nodes of this space
        ->execute()
        ->fetchCol(0);
      // clear the static node cache for the space node so correct access
      // values are tested in hook_node_access_records
      entity_get_controller('node')->resetCache(array($node->nid));
      oa_core_update_access_records($nodes);
    }
  }
  elseif ($node->type == OA_SECTION_TYPE) {
    // if section node changed from public to private, update content grants
    $was_public = oa_core_section_is_public($node->original);
    $is_public  = oa_core_section_is_public($node);
    if ($was_public != $is_public) {
      // rebuild section content nodes
      $nodes = db_select('field_data_' . OA_SECTION_FIELD, 'n')
        ->fields('n', array('entity_id'))
        ->condition('n.entity_type', 'node')
        ->condition('n.oa_section_ref_target_id', $node->nid)
        ->execute()
        ->fetchCol(0);
      // clear the static node cache for the space node so correct access
      // values are tested in hook_node_access_records
      entity_get_controller('node')->resetCache(array($node->nid));
      oa_core_update_access_records($nodes);
    }
  }
}

/**
 * Implements hook_og_fields_info().
 */
function oa_core_og_fields_info() {
  $items[OA_SECTION_FIELD] = array(
    'no ui' => TRUE,
    'type' => array('group content'),
    'description' => t('Determine to which Open Atrium section this space content is assigned to.'),
    'field' => array(
      'field_name' => OA_SECTION_FIELD,
      'type' => 'entityreference',
      'cardinality' => 1,
      'module' => 'entityreference',
      'settings' => array(
        'handler' => 'base',
        'handler_settings' => array(
          'behaviors' => array(
            'views-select-list' => array(
              'status' => 0,
            ),
          ),
          'sort' => array(
            'type' => 'none',
          ),
          'target_bundles' => array(
            OA_SECTION_TYPE => OA_SECTION_TYPE,
          ),
        ),
        'target_type' => 'node',
      ),
      'translatable' => '0',
      'type' => 'entityreference',
    ),
    'instance' => array(
      'label' => t('Open Atrium Section'),
      'widget' => array(
        'active' => 0,
        'module' => 'options',
        'settings' => array(
          'match_operator' => 'CONTAINS',
          'path' => '',
          'size' => 60,
        ),
        'type' => 'options_select',
        'weight' => '7',
      ),
    ),
  );

  return $items;
}

/**
 * Implements hook_form_alter
 */
function oa_core_form_node_form_alter(&$form, &$form_state, $form_id) {
  global $user;

  // we are in an edit form
  // autofill empty group audience field
  if (isset($form[OA_SPACE_FIELD]) && empty($form[OA_SPACE_FIELD][LANGUAGE_NONE][0]['default']['#default_value'])) {
    if (!empty($_SESSION['og_context']['gid'])) {
      $form[OA_SPACE_FIELD][LANGUAGE_NONE][0]['default']['#default_value'] = $_SESSION['og_context']['gid'];
    }
  }

  // modify label on Panelizer layout field
  if (isset($form['panelizer'])) {
    $form['panelizer']['page_manager']['name']['#title'] = t('Select Layout');
  }
}

/**
 * Returns a list of content types throughout the system. List
 *   leaves out content types specified by other modules/apps.
 *
 * @return array of strings denoting content types marked for omission
 */
function oa_core_list_content_types($space_content = FALSE) {
  $nodes = node_type_get_types();
  if ($space_content) {
    // remove types that are not space content
    foreach ($nodes as $key => $node) {
      if (!og_is_group_content_type('node', $node->type)) {
        unset($nodes[$key]);
      }
    }
  }

  // Queries hook_oa_omit_content_types to determine what content types
  //   modules wants to hide.
  $deny = module_invoke_all('oa_omit_content_types');
  if (!empty($deny)) {
    foreach ($deny as $remove) {
      unset($nodes[$remove]);
    }
  }

  return $nodes;
}

/**
 * Create a new content node within a space/section
 * @param  string $bundle  name of node bundle to create
 * @param  object $context an optional code to copy space/section from
 *   if not specified, current Session space/section context is used
 * @return object $wrapper entity metadata wrapper around node
 *
 * NOTE: The created node is NOT SAVED.  You need to use:
 *   $wrapper = oa_core_create_node(...);
 *   $wrapper->save();
 * to actually save the created node.  This allows you to set other
 * wrapper fields before saving
 */
function oa_core_create_node($bundle, $title = '', $context = NULL) {
  global $user;

  $values = array(
    'type' => $bundle,
    'uid' => $user->uid,
    'status' => 1,
    'comment' => 0,
    'promote' => 0,
  );
  $entity = entity_create('node', $values);
  $wrapper = entity_metadata_wrapper('node', $entity);

  $wrapper->title = $title;

  $space_id = $_SESSION['og_context']['gid'];
  $section_id = $_SESSION[OA_SESSION_SECTION];
  if (isset($context)) {
    // copy space and section fields from context node
    $context_wrapper = entity_metadata_wrapper('node', $context);
    if (isset($context_wrapper->{OA_SPACE_FIELD})) {
      $space_id = $context_wrapper->{OA_SPACE_FIELD}->value();
    }
    if (isset($context_wrapper->{OA_SECTION_FIELD})) {
      $section_id = $context_wrapper->{OA_SECTION_FIELD}->value();
    }
  }
  if (isset($wrapper->{OA_SPACE_FIELD})) {
    $wrapper->{OA_SPACE_FIELD} = $space_id;
  }
  if (isset($wrapper->{OA_SECTION_FIELD})) {
    $wrapper->{OA_SECTION_FIELD} = $section_id;
  }

  return $wrapper;
}

/**
 * Helper function to retrieve an array of node titles and links given
 * a list of node ids
 * @param  array  $ids array of node ids to fetch
 * @param  string $type optional node type to filter
 * @return array      associative array:
 *   'titles' is a list of node titles (clean)
 *   'links' is a list of node links
 *   'ids' is a list of the node ids
 */
function oa_core_get_titles($ids = array(), $type = '') {
  $items = array('titles' => array(), 'links' => array(), 'ids' => array());
  if (!empty($ids)) {
    $query = db_select('node', 'n');
    $query
      ->fields('n', array('nid', 'title'))
      ->condition('n.nid', $ids, 'IN');
    if (!empty($type)) {
      $query->condition('n.type', $type);
    }
    $result = $query->execute();
    while ($row = $result->fetchAssoc()) {
      $items['ids'][]    = $row['nid'];
      $items['titles'][] = check_plain($row['title']);
      $items['links'][]  = l($row['title'], 'node/' . $row['nid']);
    }
  }
  return $items;
}

/**
 * truncate a list to a given number of items with optional More link
 * @param  array $list      array to be truncated
 * @param  int $count     number of items desired
 * @param  string $more_link optional "More" link added to end of array
 * @return array            new list of items
 */
function oa_core_truncate_list($list, $count, $more_link = '') {
  $new_list = array_slice($list, 0, $count);
  if (!empty($more_link) && (count($list) != count($new_list))) {
    $new_list[] = $more_link;
  }
  return $new_list;
}

/**
 * Return a list of public spaces
 * since og_get_entity_groups doesn't return anything for anonymous users
 * @return array array['node'] contains array of public gids
 */
function oa_core_get_public_spaces() {
  $query = db_select('field_data_group_access', 'g')
    ->fields('g', array('entity_id'))
    ->condition('bundle', OA_SPACE_TYPE)
    ->condition('entity_type', 'node')
    ->condition('group_access_value', 0);
  $result['node'] = $query->execute()->fetchCol(0);
  return $result;
}

/**
 * Return a list of sections within a space
 * Uses access control, so only sections with access are returned
 * @param  int $gid space ID
 * @return keyed array of section data: $array[$nid] = $title
 */
function oa_core_space_sections($gid) {
  $query = db_select('node', 'n');
  $query->rightJoin('og_membership', 'og', 'n.nid = og.etid');
  $query
    ->fields('n', array('nid', 'title'))
    ->condition('n.type', OA_SECTION_TYPE)
    ->condition('og.entity_type', 'node')
    ->condition('og.field_name', OA_SPACE_FIELD)
    ->condition('og.gid', $gid)
    ->addTag('node_access');
  $result = $query->execute();
  return $result->fetchAllKeyed(0, 1);
}

/**
 * Return a list of all Groups
 *
 * @return
 *    An array of Groups, keyed by the group nid.
 */
function oa_core_get_all_groups() {
  $query = db_select('node', 'n');
  $query->fields('n', array('nid', 'title'))
      ->condition('n.type', OA_GROUP_TYPE)
      ->addTag('node_access');
  return $query->execute()->fetchAllAssoc('nid');
}


/**
 * Returns the users that are in a space.
 */
function oa_core_get_users_for_space($space_id) {
  $query = db_select('users', 'u');
  $query->innerJoin('og_membership', 'og', 'u.uid = og.etid');
  $query->fields('u', array('uid'))
    ->condition('og.entity_type', 'user')
    ->condition('og.gid', $space_id);
    //->condition('og.group_type', 'node');

  $results = $query->execute()->fetchAllAssoc('uid');
  return user_load_multiple(array_keys($results));
}

/**
 * Return the users that are the intersection of Group and Space membership.
 *
 * @param int $space_id
 *    The Space ID of the Open Atrium site
 * @param $group_id
 *    The Group ID
 * @return
 *    An array of Users keyed by uid
 */
function oa_core_get_group_users_for_space($space_id, $group_id) {
  $query = db_select('users', 'u');
  $query->innerJoin('og_membership', 'og1', 'u.uid = og1.etid');
  $query->innerJoin('og_membership', 'og2', 'u.uid = og2.etid');
  $query->fields('u', array('uid'))
      ->condition('og1.entity_type', 'user')
      ->condition('og1.gid', $space_id)
      ->condition('og1.group_type', 'node')
      ->condition('og2.entity_type', 'user')
      ->condition('og2.gid', $group_id)
      ->condition('og1.group_type', 'node');

  $results = $query->execute()->fetchAllAssoc('uid');
  return user_load_multiple(array_keys($results));
}

/**
 * Implements hook_preprocess_views_view_fields().
 * Perform field-level replacement/processing here
 */
function oa_core_preprocess_views_view_fields(&$vars) {
  $vars['index'] = $vars['view']->row_index;
  $vars['display'] = $vars['view']->current_display;
  foreach ($vars['fields'] as $id => $field) {
    $vars[$id] = $field->content;
  }
  // View specific alterations.
  if ($vars['view']->name == 'oa_user_spaces' && $vars['view']->current_display == 'full') {
    oa_core_preprocess_oa_user_spaces_full_view_fields($vars);
  }
}


/**
 * Views view fields preprocess function.
 * Provide the template with the space's sections for display.
 */
function oa_core_preprocess_oa_user_spaces_full_view_fields(&$vars) {
  $space = node_load($vars['row']->node_og_membership_nid);
  $sections = oa_core_space_sections($space->nid);
  $vars['sections'] = array();
  foreach ($sections as $id => $title) {
    $vars['sections'][$id]['title'] = $title;
    $vars['sections'][$id]['href'] = url('node/' . $id);
  }
}


/**
 * Return a list of space ids that a user belongs to.
 */
function oa_core_get_user_spaces($uid) {
  $query = db_select('og_membership', 'og')
    ->fields('og')
    ->condition('entity_type', 'user')
    ->condition('etid', $uid);

  $results = $query->execute()->fetchAllAssoc('gid');
  return array_keys($results);
}


/**
 * Returns the space ID that a node belongs to.
 */
function oa_core_get_node_space($nid) {
  $query = db_select('og_membership', 'og')
    ->fields('og')
    ->condition('entity_type', 'node')
    ->condition('etid', $nid);

  $result = $query->execute()->fetchAssoc();
  return empty($result) ? 0 : $result['gid'];
}
